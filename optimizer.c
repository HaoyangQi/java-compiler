#include "optimizer.h"

/**
 * initialize optimizer for given code graph
 *
 * NOTE: this process only fills information, no data will be allocated
 *
 * e.g.
 * instruction-indexed array will not be initialized here, because its size
 * needs to count phi statements generated by SSA process
 *
 * TODO: probably just register using top-level,
 * and do everything within?
*/
void init_optimizer(optimizer* om, global_top_level* top_level, definition* target)
{
    if (!om || !target) { return; }

    memset(om, 0, sizeof(optimizer));
    init_definition_pool(&om->spill_pool);

    /**
     * TODO: how to handle member init code?
     * we do not optimize: because member init code cannot use "local" variables anyway
     * but we do generate temp variables, that could be tricky
     * so we probably have to do it anyway?
    */
    switch (target->type)
    {
        case DEFINITION_METHOD:
            om->graph = &target->method->code;
            om->node_postorder = cfg_node_order(om->graph, DFS_POSTORDER);

            /**
             * NOTE:
             *
             * om->profile.num_members counts total number of member variables
             * on top level, instead of target->method->member_variable_use_count,
             * because the index id "mid" is used to index variables, so all
             * slots need to be reserved
            */
            om->profile.num_locals = target->method->local_variables.num;
            om->profile.num_members = top_level->num_fields;
            om->profile.num_variables = om->profile.num_members + om->profile.num_locals;
            om->profile.num_instructions = target->method->instruction_count;
            break;
        default:
            // halt if target is invalid
            return;
    }
}

/**
 * release optimizer
*/
void release_optimizer(optimizer* om)
{
    if (!om || !om->graph) { return; }

    for (size_t i = 0; i < om->profile.num_instructions; i++)
    {
        release_index_set(&om->instructions[i].def);
        release_index_set(&om->instructions[i].use);
        release_index_set(&om->instructions[i].in);
        release_index_set(&om->instructions[i].out);
    }

    cfg_delete_node_order(om->node_postorder);
    free(om->variables);
    free(om->instructions);
    release_definition_pool(&om->spill_pool);
}

/**
 * execute optimization
 *
 * execution order here matters
 *
 * all processes involve instruction-id-indexed-array:
 * its size needs to count phi statements generated by SSA process
*/
void optimizer_execute(optimizer* om)
{
    optimizer_populate_variables(om);

    // SSA begin
    optimizer_ssa_build(om);

    /**
     * TODO:
     * here, in SSA form, do optimizations that depend on it;
     * call optimizer_populate_instructions if necessary,
     * but need to re-populate after eliminating SSA form
    */

    // SSA end
    optimizer_ssa_eliminate(om);

    optimizer_allocator_heuristic(om, 4);
}
